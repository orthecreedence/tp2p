//! While syncing allows multiple nodes to share data, the identity module
//! allows those nodes to know *who* they are sharing data with. All messages
//! are signed by the identity key, which allows for more accurate routing and
//! security between peers.

use chrono::{DateTime, Utc};
use crate::{
    error::{Error, Result},
    message,
    ser,
};
use getset::{Getters};
use serde_derive::{Serialize, Deserialize};
use sodiumoxide::crypto::{box_, sign};
use std::ops::Deref;

/// An identity's public key.
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize, Getters)]
#[getset(get = "pub")]
pub struct Pubkey {
    inner: sign::PublicKey,
}

impl Deref for Pubkey {
    type Target = sign::PublicKey;
    fn deref(&self) -> &Self::Target {
        self.inner()
    }
}

impl Pubkey {
    /// Create a new public key.
    pub fn new(pubkey: sign::PublicKey) -> Self {
        Self {
            inner: pubkey,
        }
    }
}

/// An identity keypair, generally created from a seed generated by the user's
/// username/password.
///
/// This is used to sign messages to prove ownership of resources.
#[derive(Clone, Debug, Getters)]
#[getset(get = "pub")]
pub struct Identity {
    pubkey: sign::PublicKey,
    seckey: sign::SecretKey,
}

impl Identity {
    /// Create a new identity from a raw public/secret keypair
    pub fn new(pubkey: sign::PublicKey, seckey: sign::SecretKey) -> Self {
        Self {
            pubkey,
            seckey,
        }
    }

    /// Create a new identity from a seed.
    pub fn new_with_seed(seed_bytes: &[u8]) -> Result<Self> {
        let seed = sign::Seed::from_slice(seed_bytes)
            .ok_or(Error::KeypairFromSeedFailed)?;
        let (pubkey, seckey) = sign::keypair_from_seed(&seed);
        Ok(Self::new(pubkey, seckey))
    }

    /// Create a Pubkey from this Keypair.
    pub fn to_pubkey(&self) -> Pubkey {
        Pubkey::new(self.pubkey.clone())
    }
}

/// A pathetically simple proof of identity.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct IdentityProof {
    /// The time the proof was created.
    date: DateTime<Utc>,
    /// A random nonce.
    nonce: box_::Nonce,
    /// The proof signature, created with the Identity secke, created with the Identity secke,
    /// created with the Identity secke, created with the Identity secke, created with the Identity
    /// secke, created with the Identity secke, created with the Identity secke, created with the
    /// Identity secke, created with the Identity secke, created with the Identity secke, created
    /// with the Identity secke, created with the Identity secke, created with the Identity secke,
    /// created with the Identity secke, created with the Identity seckey
    signature: sign::ed25519::Signature,
}

impl IdentityProof {
    /// Create a proof of identity.
    pub fn prove(identity: &Identity, now: &DateTime<Utc>) -> Result<Self> {
        let nonce = message::gen_nonce();
        let sign_me = (&now, &nonce);
        let serialized = ser::serialize(&sign_me)?;
        let signature = sign::sign_detached(&serialized, identity.seckey());
        Ok(Self {
            date: now.clone(),
            nonce,
            signature,
        })
    }
}

